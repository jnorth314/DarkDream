from functools import cache
import json
import os
import sys
import typing

import cv2
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QIcon, QImage, QPixmap
from PyQt6.QtWidgets import QFrame, QHBoxLayout, QLabel, QGridLayout, QPushButton, QWidget, QVBoxLayout

@cache
def get_tiles() -> list[cv2.typing.MatLike]:
    """Return a list of images of all tiles that make up a minimap"""

    path_to_tiles = (
        os.path.join(sys._MEIPASS, "res/tiles.png") if getattr(sys, "frozen", False) else # type: ignore # pylint: disable=protected-access
        os.path.join(os.path.dirname(os.path.abspath(__file__)), "../res/tiles.png")
    )

    tiles = cv2.imread(path_to_tiles)

    return [
        tiles[y:y + 16, x:x + 16]
        for y in range(0, 16*6, 16)
        for x in range(0, 16*8, 16)
    ]

@cache
def get_maps() -> list[list[list[int]]]:
    """Get all of the maps generated by Dark Cloud"""

    path_to_maps = (
        os.path.join(sys._MEIPASS, "res/maps.json") if getattr(sys, "frozen", False) else # type: ignore # pylint: disable=protected-access
        os.path.join(os.path.dirname(os.path.abspath(__file__)), "../res/maps.json")
    )

    with open(path_to_maps, "r", encoding="utf-8") as f:
        maps: dict[str, list[list[int]]] = json.load(f)
        return list(maps.values())

def is_matching_dungeon(dungeon: list[list[int]], map_: list[list[int]]) -> bool:
    """Return whether the discovered portions of a dungeon matches the given map"""

    return all(dungeon[y][x] in (-1, 42, 43, 44, 45, 46, 47) or dungeon[y][x] == map_[y][x]
               for x in range(15)
               for y in range(15))

class TileButton(QPushButton): # pragma: no cover
    """Button that holds Tile information"""

    def __init__(self, x: int, y: int, id_: int) -> None:
        super().__init__()

        self.x_ = x
        self.y_ = y

        self.id = id_

        self.setFixedSize(16, 16)
        self.set_icon()

    def set_icon(self) -> None:
        """Set the icon to the tile matching the ID"""

        if self.id != -1:
            tiles = get_tiles()

            image = QImage(tiles[self.id].tobytes(), 16, 16, 48, QImage.Format.Format_BGR888)
            pixmap = QPixmap(image)
            icon = QIcon(pixmap)

            self.setIcon(icon)
        else:
            self.setIcon(QIcon())

class DungeonFrame(QFrame): # pragma: no cover
    """Frame to hold dungeon information"""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent=parent)

        self.buttons = [[TileButton(x, y, -1) for x in range(15)] for y in range(15)]

        layout = QGridLayout()
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)

        for x in range(15):
            for y in range(15):
                self.buttons[y][x].setCheckable(True)
                layout.addWidget(self.buttons[y][x], y, x)

        self.setLayout(layout)
        self.setFixedSize(16*15, 16*15)

class TileFrame(QFrame): # pragma: no cover
    """Frame to hold tile information from the tileset"""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent=parent)

        self.buttons = [[TileButton(x, y, 8*y + x) for x in range(8)] for y in range(6)]

        layout = QGridLayout()
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)

        for x in range(8):
            for y in range(6):
                layout.addWidget(self.buttons[y][x], y, x)

        self.setLayout(layout)
        self.setFixedSize(16*8, 16*6)

class CompareWidget(QWidget): # pragma: no cover
    """Widget to handle doing comparisons from user input to the maps"""

    def __init__(self) -> None:
        super().__init__()

        self.dungeon = DungeonFrame(self)
        self.tiles = TileFrame(self)

        for x in range(15):
            for y in range(15):
                self.dungeon.buttons[y][x].clicked.connect(self.on_tile_toggle)

        for x in range(8):
            for y in range(6):
                self.tiles.buttons[y][x].clicked.connect(self.on_tile_set)

        button = QPushButton()
        button.setText("Reset")
        button.clicked.connect(self.on_reset)
        button.setMinimumWidth(self.dungeon.minimumWidth())

        self.label = QLabel()
        self.label.setText("21475/21475 Matches")
        self.label.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.label.setMinimumWidth(self.tiles.minimumWidth())

        column = QVBoxLayout()

        row1 = QHBoxLayout()
        row1.addWidget(self.dungeon)
        row1.addWidget(self.tiles)

        row2 = QHBoxLayout()
        row2.addWidget(button)
        row2.addWidget(self.label)

        column.addLayout(row1)
        column.addLayout(row2)
        self.setLayout(column)

    def get_checked_tile(self) -> TileButton | None:
        """Get the currently checked tile of the dungeon map"""

        for x in range(15):
            for y in range(15):
                if self.dungeon.buttons[y][x].isChecked():
                    return self.dungeon.buttons[y][x]

        return None

    @typing.no_type_check
    def on_tile_toggle(self) -> None:
        """Callback for when a dungeon tile is selected"""

        for x in range(15):
            for y in range(15):
                self.dungeon.buttons[y][x].setChecked(False)

        self.sender().setChecked(True)

    @typing.no_type_check
    def on_tile_set(self) -> None:
        """Callback for when a tile from the set is selected"""

        tile = self.get_checked_tile()

        if tile is not None:
            tile.id = self.sender().id
            tile.set_icon()

        self.check_matching_dungeon()

    def on_reset(self) -> None:
        """Callback for when the reset button is clicked"""

        for x in range(15):
            for y in range(15):
                self.dungeon.buttons[y][x].id = -1
                self.dungeon.buttons[y][x].set_icon()

        self.label.setText("21475/21475 Matches")

    def check_matching_dungeon(self) -> None:
        """Check if the dungeon is a match and set the rest of the tiles if so"""

        dungeon = [[self.dungeon.buttons[y][x].id for x in range(15)] for y in range(15)]

        matching_dungeons = [map_ for map_ in get_maps() if is_matching_dungeon(dungeon, map_)]

        self.label.setText(f"{len(matching_dungeons)}/21475 Matches")

        if len(matching_dungeons) == 1:
            map_ = matching_dungeons[0]

            for x in range(15):
                for y in range(15):
                    self.dungeon.buttons[y][x].id = map_[y][x]
                    self.dungeon.buttons[y][x].set_icon()
